smooth_trace = profile_light_loess$trace.hat,
fit_method = loess.criterion)
# loess.fit$vessel <- x$vessel[1]
# loess.fit$cruise <- x$cruise[1]
# loess.fit$haul <- x$haul[1]
# Output residuals
resids <- data.frame(residual = residuals(profile_light_loess),
log_trans_llight = log(x$trans_llight),
cdepth = x$cdepth)
# resids$vessel <- x$vessel[1]
# resids$cruise <- x$cruise[1]
# resids$haul <- x$haul[1]
output_dfs <- list(fit_atten = loess.fit, attenuation = output, fit_residuals = resids)
return(output_dfs)
}
}
head(test.filter_stepwise)
filter_stepwise <- function(cast.data, light.col, depth.col, bin.size = 2, bin.gap = 6, agg.fun, ...) {
names(cast.data)[which(names(cast.data) == light.col)] <- "trans_llight"
names(cast.data)[which(names(cast.data) == depth.col)] <- "cdepth"
max.depth <- max(ceiling(cast.data$cdepth), na.rm = T)
# Bin by depth with bins centered
cast.data$cdepth <- findInterval(cast.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2
# # Convert light data
# cast.data$trans_llight <- convert_light(cast.data$llight)
# Calculate binned light level using user-specified function
light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = cast.data, FUN = eval(parse(text = paste(agg.fun))))
light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
# Stepwise measurement removal loop
p2 <- 1
while(p2 < nrow(light_at_depth) ) {
if(nrow(light_at_depth) >= (p2 + 1)) {
if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
light_at_depth <- light_at_depth[-p2,]
p2 <- 0 # Index back to start
}
}
p2 <- p2 + 1
}
# Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
light_at_depth$quality <- 1
} else {
light_at_depth$quality <- -999
}
names(cast.data)[which(names(cast.data) == "trans_llight")] <- light.col
names(cast.data)[which(names(cast.data) == "cdepth")] <- depth.col
return(light_at_depth)
}
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.filter_stepwise)
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.filter_stepwise)
filter_stepwise <- function(cast.data, light.col, depth.col, bin.size = 2, bin.gap = 6, agg.fun, ...) {
names(cast.data)[which(names(cast.data) == light.col)] <- "trans_llight"
names(cast.data)[which(names(cast.data) == depth.col)] <- "cdepth"
max.depth <- max(ceiling(cast.data$cdepth), na.rm = T)
# Bin by depth with bins centered
cast.data$cdepth <- findInterval(cast.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2
# # Convert light data
# cast.data$trans_llight <- convert_light(cast.data$llight)
# Calculate binned light level using user-specified function
light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = cast.data, FUN = eval(parse(text = paste(agg.fun))))
light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
# Stepwise measurement removal loop
p2 <- 1
while(p2 < nrow(light_at_depth) ) {
if(nrow(light_at_depth) >= (p2 + 1)) {
if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
light_at_depth <- light_at_depth[-p2,]
p2 <- 0 # Index back to start
}
}
p2 <- p2 + 1
}
# Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
light_at_depth$quality <- 1
} else {
light_at_depth$quality <- -999
}
names(cast.data)[which(names(cast.data) == "trans_llight")] <- light.col
names(cast.data)[which(names(cast.data) == "cdepth")] <- depth.col
return(light_at_depth)
}
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.filter_stepwise)
filter_stepwise <- function(cast.data, light.col, depth.col, bin.size = 2, bin.gap = 6, agg.fun, ...) {
names(cast.data)[which(names(cast.data) == light.col)] <- "trans_llight"
names(cast.data)[which(names(cast.data) == depth.col)] <- "cdepth"
max.depth <- max(ceiling(cast.data$cdepth), na.rm = T)
# Bin by depth with bins centered
cast.data$cdepth <- findInterval(cast.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2
# # Convert light data
# cast.data$trans_llight <- convert_light(cast.data$llight)
# Calculate binned light level using user-specified function
light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = cast.data, FUN = eval(parse(text = paste(agg.fun))))
light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
# Stepwise measurement removal loop
p2 <- 1
while(p2 < nrow(light_at_depth) ) {
if(nrow(light_at_depth) >= (p2 + 1)) {
if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
light_at_depth <- light_at_depth[-p2,]
p2 <- 0 # Index back to start
}
}
p2 <- p2 + 1
}
# Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
light_at_depth$quality <- 1
} else {
light_at_depth$quality <- -999
}
names(light_at_depth)[which(names(light_at_depth) == "trans_llight")] <- light.col
names(light_at_depth)[which(names(light_at_depth) == "cdepth")] <- depth.col
return(light_at_depth)
}
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.filter_stepwise)
calculate_attenuation(light.col = )
calculate_attenuation(x = test.filter_stepwise, light.col = "light_tight", depth.col = "cdepth")
test.calculate_attenuation <- calculate_attenuation(x = test.filter_stepwise, light.col = "light_tight", depth.col = "cdepth")
light_proportion <- function(x, water.col = "trans_llight", depth.col = "cdepth", ...) {
names(x)[names(x) == water.col] <- "trans_llight"
names(x)[names(x) == depth.col] <-  "cdepth"
# Light ratio relative to shallowest bin.
x$light_ratio <- x$trans_llight / max(x$trans_llight, na.rm = T)
# Linear attenuation coefficient relative to shallowest bin.
x$k_linear <- log(x$trans_llight/max(x$trans_llight)) / (min(x$cdepth) - x$cdepth)
# Whole column attenuation coefficient.
x$k_column <- rep((log(min(x$trans_llight)/max(x$trans_llight))) / (min(x$cdepth) - max(x$cdepth)), nrow(x))
names(x)[names(x) == "trans_llight"] <- water.col
names(x)[names(x) == "cdepth"] <-  depth.col
return(x)
}
light_proportion <- function(x, light.col = "trans_llight", depth.col = "cdepth", ...) {
names(x)[names(x) == light.col] <- "trans_llight"
names(x)[names(x) == depth.col] <-  "cdepth"
# Light ratio relative to shallowest bin.
x$light_ratio <- x$trans_llight / max(x$trans_llight, na.rm = T)
# Linear attenuation coefficient relative to shallowest bin.
x$k_linear <- log(x$trans_llight/max(x$trans_llight)) / (min(x$cdepth) - x$cdepth)
# Whole column attenuation coefficient.
x$k_column <- rep((log(min(x$trans_llight)/max(x$trans_llight))) / (min(x$cdepth) - max(x$cdepth)), nrow(x))
names(x)[names(x) == "trans_llight"] <- light.col
names(x)[names(x) == "cdepth"] <-  depth.col
return(x)
}
light_proportion(x = test.vert, light.col = "light_tight", depth.col = "cdepth")
names(test.vert)[which(names(test.vert) == "cdepth"])]
names(test.vert)[which(names(test.vert) == "cdepth")]
names(test.vert)[which(names(test.vert) == "cdepth")] <- "z"
test.casts <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/corr_MK9hauls.csv")
test.times <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/CastTimes.csv")
test.casts$ctime <- as.POSIXct(strptime(test.casts$ctime, format = "%Y-%m-%d %H:%M:%S"))
test.times$downcast_start <- as.POSIXct(strptime(test.times$downcast_start, format = "%Y-%m-%d %H:%M:%S")) - 20
test.times$downcast_end <- as.POSIXct(strptime(test.times$downcast_end, format = "%Y-%m-%d %H:%M:%S")) + 20
test.times$upcast_start <- as.POSIXct(strptime(test.times$upcast_start, format = "%Y-%m-%d %H:%M:%S")) - 20
test.times$upcast_end <- as.POSIXct(strptime(test.times$upcast_end, format = "%Y-%m-%d %H:%M:%S")) + 20
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 13))
test.vert <- subset(test.vert, updown == "Downcast")
names(test.vert)[which(names(test.vert) == "cdepth")] <- "z"
test.vert$light_tight <- convert_light(test.vert$llight)
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "z")
head(test.filter_stepwise)
test.calculate_attenuation <- calculate_attenuation(x = test.filter_stepwise, light.col = "light_tight", depth.col = "z")
light_proportion(x = test.vert, light.col = "light_tight", depth.col = "z")
test.casts <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/corr_MK9hauls.csv")
test.times <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/CastTimes.csv")
test.casts$ctime <- as.POSIXct(strptime(test.casts$ctime, format = "%Y-%m-%d %H:%M:%S"))
require(devtools)
devtools::create("trawllight")
package?devtools
?findInterval
test.casts <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/corr_MK9hauls.csv")
test.times <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/CastTimes.csv")
test.casts$ctime <- as.POSIXct(strptime(test.casts$ctime, format = "%Y-%m-%d %H:%M:%S"))
test.times$downcast_start <- as.POSIXct(strptime(test.times$downcast_start, format = "%Y-%m-%d %H:%M:%S")) - 20
test.times$downcast_end <- as.POSIXct(strptime(test.times$downcast_end, format = "%Y-%m-%d %H:%M:%S")) + 20
test.times$upcast_start <- as.POSIXct(strptime(test.times$upcast_start, format = "%Y-%m-%d %H:%M:%S")) - 20
test.times$upcast_end <- as.POSIXct(strptime(test.times$upcast_end, format = "%Y-%m-%d %H:%M:%S")) + 20
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 13))
test.vert <- subset(test.vert, updown == "Downcast")
names(test.vert)[which(names(test.vert) == "cdepth")] <- "z"
test.vert$light_tight <- convert_light(test.vert$llight)
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "z")
head(test.filter_stepwise)
test.calculate_attenuation <- calculate_attenuation(x = test.filter_stepwise, light.col = "light_tight", depth.col = "z")
test.light_proportion <- light_proportion(x = test.vert, light.col = "light_tight", depth.col = "z")
require(roxygen2)
roxygenize(package.dir = getwd())
?data.frame
roxygenize(package.dir = getwd())
?document
document(getwd())
roxygenize(package.dir = getwd())
roxygenize(package.dir = getwd())
find.package(trawllight)
find.package(trawllight)
library(trawllight)
find.package(trawllight)
?convert_light
find.package("trawllight")
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(find.package("trawllight"))))
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(find.package("trawllight"))))
ls.all()
ls()
rm(list = ls())
require(trawllight)
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(path)))
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(find.package("trawllight"))))
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(find.package("trawllight"))))
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(find.package("trawllight"))))
require(devtools)
check(find.package("trawllight"), cleanup = F)
find.package("trawllight")
R CMD
R CMD Rd2pdf
install.packages("PkgUtils")
require(PkgUtils)
library(trawllight)
?convert_light
?use_vignette
use_vignette("trawllight")
1.
1.75*5
37/2
37/2/8
37/2/10
paste("trans_llight", paste(x1, collapse = "+"), sep = "~")
?aggregate
library(trawllight)
library(trawllight)
View(filter_stepwise())
View(filter_stepwise
)
library(trawllight)
library(trawllight)
library(trawllight)
library(trawllight)
View(geometric.mean)
View(mean)
x <- c(-1,2,3)
any(x > 0)
any(x < 0)
x <- c(0,2,3)
any(x < 0)
log(0)
any(x <= 0)
?log
library(trawllight)
install.packages"TMB"
install.packages(TMB)
install.packages("TMB")
library(TMB)
runExample(all = T)
install.packages(c("plyr", "dplyr", "reshape", "reshape2", "ggplot2", "mgcv", "MASS", "fANCOVA", "roxygen2", "knitr", "vegan", "raster", "ggmap", "GGally", "gridExtra"))
library(trawllight)
library(trawllight)
library(trawllight)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
plot(1:10)
plot(10:1)
knitr::kable(head(mtcars, 10))
head(light_ratios)
library(trawllight)
?residuals
getwd("../")
dir("../")
dir("..//../")
Sys.info()
library(trawllight)
library(trawllight)
library(trawllight)
library(trawllight)
View(process_all)
library(trawllight)
library(trawllight)
library(trawllight)
View(pnorm)
library(trawllight)
library(trawllight)
library(trawllight)
library(trawllight)
library(trawllight)
dir(.."")
dir("..")
dir("../..")
dir("../../..")
dir("../../../Coursework")
dir("../../../Coursework/FISH 559 - Numerical Computing/")
dir("../../../Coursework/FISH 559 - Numerical Computing/Assignments/")
dir("../../../Coursework/FISH 559 - Numerical Computing/Assignments/Assignment1")
read.table("../../../Coursework/FISH 559 - Numerical Computing/Assignments/Assignment1")
library(trawllight)
library(trawllight)
library(trawllight)
library(trawllight)
library(trawllight)
library(trawllight)
NA >2
test <- data.frame(vessel = rep(1:3, 3), cruise = rep(c(199201:199203, 3)), haul = rep(1,9))
test <- data.frame(vessel = rep(1:3, 3), cruise = rep(199201:199203, 3), haul = rep(1,9))
test
test <- data.frame(vessel = rep(1:3, 3), cruise = rep(199201:199203, 3), haul = rep(1,9))
test <- data.frame(vessel = rep(1:3, 3), cruise = rep(199201:199203, 3), haul = rep(1,9), cdepth = rep(5:7,3))
test
test <- data.frame(vessel = rep(1:3, 3), cruise = rep(199201:199203, 3), haul = rep(1,9), cdepth = rep(5:7,3), rr = rnorm(9))
test
reshape::cast(data = test, vessel + cruise + haul ~ cdepth)
reshape::cast(data = test, vessel + cruise + haul ~ cdepth, value = rr)
reshape::cast(data = test, vessel + cruise + haul ~ cdepth, value.var = rr)
reshape::cast(data = test, vessel + cruise + haul ~ cdepth, value = "rr")
reshape2::cast(data = test, vessel + cruise + haul ~ cdepth, value = "rr")
reshape2::cast.data.frame(data = test, vessel + cruise + haul ~ cdepth, value = "rr")
reshape2::cast(data = test, vessel + cruise + haul ~ cdepth, value = "rr")
test <- data.frame(vessel = c(1,1,1,2,2,2,3,3,3), cruise = rep(199201:199203, 3), haul = rep(1,9), cdepth = rep(5:7,3), rr = rnorm(9))
reshape2::cast(data = test, vessel + cruise + haul ~ cdepth, value = "rr")
reshape::cast(data = test, vessel + cruise + haul ~ cdepth, value = "rr")
test <- data.frame(vessel = rep(1,9), cruise = rep(199201:199203, 3), haul = rep(1,9), cdepth = rep(5:7,3), rr = rnorm(9))
test
reshape::cast(data = test, vessel + cruise + haul ~ cdepth, value = "rr")
test
test <- data.frame(vessel = rep(1,9), cruise = c(rep(199201, 3), rep(199301,3), rep(199401,3)), haul = rep(1, 9), cdepth = rep(5:7,3), rr = rnorm(9))
test
reshape::cast(data = test, vessel + cruise + haul ~ cdepth, value = "rr")
assign_orientation <- function(x, formula = vessel + cruise + haul ~ cdepth,
resid.col,
resid.cut) { #,
# name.orientation = FALSE) {
x.cast <- cast(x, formula, value = resid.col)
x.cast$orientation <- "Bad"
n.iter <- length(unique(x[,which(names(x) == labels(terms(formula)))]))
last.col <- ncol(x.cast) - n.iter
if(length(resid.cut) > 1) {
resid.cut <- rev(resid.cut)
} else {
resid.cut <- rep(resid.cut, n.iter)
}
iter.count <- 1
for(i in (ncol(x.cast)-1):last.col){
x.cast$orientation[x.cast[,i] > resid.cut[iter.count]] <- "Good"
iter.count <- iter.count + 1
}
# if(name.orientation != F) {
#   names(x.cast)[ncol(x.cast)] <- name.orientation
# }
x.out <- merge(x, unique(x.cast[, c(1:(ncol(x.cast)-n.iter-1), ncol(x.cast))]))
return(x.out)
}
assign_orientation(x = test. resid.col = "rr", resid.cut = 0)
assign_orientation(x = test, resid.col = "rr", resid.cut = 0)
assign_orientation <- function(x, formula = vessel + cruise + haul ~ cdepth,
resid.col,
resid.cut) { #,
# name.orientation = FALSE) {
x.cast <- reshape::cast(x, formula, value = resid.col)
x.cast$orientation <- "Bad"
n.iter <- length(unique(x[,which(names(x) == labels(terms(formula)))]))
last.col <- ncol(x.cast) - n.iter
if(length(resid.cut) > 1) {
resid.cut <- rev(resid.cut)
} else {
resid.cut <- rep(resid.cut, n.iter)
}
iter.count <- 1
for(i in (ncol(x.cast)-1):last.col){
x.cast$orientation[x.cast[,i] > resid.cut[iter.count]] <- "Good"
iter.count <- iter.count + 1
}
# if(name.orientation != F) {
#   names(x.cast)[ncol(x.cast)] <- name.orientation
# }
x.out <- merge(x, unique(x.cast[, c(1:(ncol(x.cast)-n.iter-1), ncol(x.cast))]))
return(x.out)
}
assign_orientation(x = test, resid.col = "rr", resid.cut = 0)
assign_orientation <- function(x, formula = vessel + cruise + haul ~ cdepth,
resid.col,
resid.cut) { #,
# name.orientation = FALSE) {
x.cast <- reshape::cast(x, formula, value = resid.col)
x.cast$orientation <- "Bad"
n.iter <- length(unique(x[,which(names(x) == labels(terms(formula)))]))
last.col <- ncol(x.cast) - n.iter
if(length(resid.cut) > 1) {
resid.cut <- rev(resid.cut)
} else {
resid.cut <- rep(resid.cut, n.iter)
}
iter.count <- 1
for(i in (ncol(x.cast)-1):last.col){
print(x.cast[,i])
print(resid.cut[iter.count])
x.cast$orientation[x.cast[,i] > resid.cut[iter.count]] <- "Good"
iter.count <- iter.count + 1
}
# if(name.orientation != F) {
#   names(x.cast)[ncol(x.cast)] <- name.orientation
# }
x.out <- merge(x, unique(x.cast[, c(1:(ncol(x.cast)-n.iter-1), ncol(x.cast))]))
return(x.out)
}
assign_orientation <- function(x, formula = vessel + cruise + haul ~ cdepth,
resid.col,
resid.cut) { #,
# name.orientation = FALSE) {
x.cast <- reshape::cast(x, formula, value = resid.col)
x.cast$orientation <- "Bad"
n.iter <- length(unique(x[,which(names(x) == labels(terms(formula)))]))
last.col <- ncol(x.cast) - n.iter
if(length(resid.cut) > 1) {
resid.cut <- rev(resid.cut)
} else {
resid.cut <- rep(resid.cut, n.iter)
}
iter.count <- 1
for(i in (ncol(x.cast)-1):last.col){
print(x.cast[,i])
print(resid.cut[iter.count])
x.cast$orientation[x.cast[,i] > resid.cut[iter.count]] <- "Good"
iter.count <- iter.count + 1
}
# if(name.orientation != F) {
#   names(x.cast)[ncol(x.cast)] <- name.orientation
# }
x.out <- merge(x, unique(x.cast[, c(1:(ncol(x.cast)-n.iter-1), ncol(x.cast))]))
return(x.out)
}
assign_orientation(x = test, resid.col = "rr", resid.cut = 0)
assign_orientation <- function(x, formula = vessel + cruise + haul ~ cdepth,
resid.col,
resid.cut) { #,
# name.orientation = FALSE) {
x.cast <- reshape::cast(x, formula, value = resid.col)
x.cast$orientation <- "Bad"
n.iter <- length(unique(x[,which(names(x) == labels(terms(formula)))]))
last.col <- ncol(x.cast) - n.iter
if(length(resid.cut) > 1) {
resid.cut <- rev(resid.cut)
} else {
resid.cut <- rep(resid.cut, n.iter)
}
iter.count <- 1
for(i in (ncol(x.cast)-1):last.col){
print(x.cast[,i])
print(resid.cut[iter.count])
print(names(x.cast[i]))
print(x.cast[,i] > resid.cut[iter.count])
x.cast$orientation[x.cast[,i] > resid.cut[iter.count]] <- "Good"
iter.count <- iter.count + 1
}
# if(name.orientation != F) {
#   names(x.cast)[ncol(x.cast)] <- name.orientation
# }
x.out <- merge(x, unique(x.cast[, c(1:(ncol(x.cast)-n.iter-1), ncol(x.cast))]))
return(x.out)
}
assign_orientation(x = test, resid.col = "rr", resid.cut = 0)
assign_orientation <- function(x, formula = vessel + cruise + haul ~ cdepth,
resid.col,
resid.cut) { #,
# name.orientation = FALSE) {
x.cast <- reshape::cast(x, formula, value = resid.col)
x.cast$orientation <- "Bad"
n.iter <- length(unique(x[,which(names(x) == labels(terms(formula)))]))
last.col <- ncol(x.cast) - n.iter
if(length(resid.cut) > 1) {
resid.cut <- rev(resid.cut)
} else {
resid.cut <- rep(resid.cut, n.iter)
}
iter.count <- 1
for(i in (ncol(x.cast)-1):last.col){
print(x.cast[,i])
print(resid.cut[iter.count])
print(names(x.cast[i]))
print(x.cast[,i] > resid.cut[iter.count])
x.cast$orientation[x.cast[,i] > resid.cut[iter.count]] <- "Good"
x.cast$orientation[x.cast[,i] < resid.cut[iter.count]] <- "Bad"
iter.count <- iter.count + 1
}
# if(name.orientation != F) {
#   names(x.cast)[ncol(x.cast)] <- name.orientation
# }
x.out <- merge(x, unique(x.cast[, c(1:(ncol(x.cast)-n.iter-1), ncol(x.cast))]))
return(x.out)
}
assign_orientation(x = test, resid.col = "rr", resid.cut = 0)
library(trawllight)
rm(list = ls())
library(trawllight)
library(trawllight)
library(trawllight)
library(trawllight)
library(trawllight)
log(1)-log(1)
log(1)-log(2.303)
log(1)-log(0.1)
21+42+46+20+45+49+48+22
library(trawllight)
?density
?h_OSCV_dens
library(trawllight)
library(trawllight)
