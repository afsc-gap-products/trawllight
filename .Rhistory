dir("D:/Projects/OneDrive/Thesis")
dir("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea")
dir("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/")
dir("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/")
dir("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/")
dir("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/")
dir("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/")
dir("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/")
cast_test <- ("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/corr_MK9hauls.csv")
test.casts <- ("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/corr_MK9hauls.csv")
test.times <- ("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/CastTimes.csv")
rm(cast_test)
head(test.times)
test.casts <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/corr_MK9hauls.csv")
test.times <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/CastTimes.csv")
head(test.times)
test.casts$ctime <- as.POSIXct(strptime(test.casts$ctime, format = "%Y-%m-%d %H:%M:%S"))
test.times$downcast_start <- as.POSIXct(strptime(test.times$downcast_start, format = "%Y-%m-%d %H:%M:%S")) - time.buffer
test.times$downcast_end <- as.POSIXct(strptime(test.times$downcast_end, format = "%Y-%m-%d %H:%M:%S")) + time.buffer
test.times$upcast_start <- as.POSIXct(strptime(test.times$upcast_start, format = "%Y-%m-%d %H:%M:%S")) - time.buffer
test.times$upcast_end <- as.POSIXct(strptime(test.times$upcast_end, format = "%Y-%m-%d %H:%M:%S")) + time.buffer
test.casts <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/corr_MK9hauls.csv")
test.times <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/CastTimes.csv")
test.casts$ctime <- as.POSIXct(strptime(test.casts$ctime, format = "%Y-%m-%d %H:%M:%S"))
test.times$downcast_start <- as.POSIXct(strptime(test.times$downcast_start, format = "%Y-%m-%d %H:%M:%S")) - 20
test.times$downcast_end <- as.POSIXct(strptime(test.times$downcast_end, format = "%Y-%m-%d %H:%M:%S")) + 20
test.times$upcast_start <- as.POSIXct(strptime(test.times$upcast_start, format = "%Y-%m-%d %H:%M:%S")) - 20
test.times$upcast_end <- as.POSIXct(strptime(test.times$upcast_end, format = "%Y-%m-%d %H:%M:%S")) + 20
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 4))
#===================================================#
# STEP 1: Generate vertical profiles                #
#===================================================#
vertical_profiles <- function(light.data, cast.data, ...) {
# Remove surface data
light.data <- subset(light.data, cdepth >= 0)
# Create empty columns for cast direction (updown) and haul number
light.data$updown <- rep(NA, nrow(light.data))
light.data$haul <- rep(NA, nrow(light.data))
# Assign upcast or downcast to times
light.data$updown[light.data$ctime > cast.data$downcast_start & light.data$ctime < cast.data$downcast_end[1]] <- "Downcast"
light.data$updown[light.data$ctime > cast.data$upcast_start & light.data$ctime < cast.data$upcast_end[1]] <- "Upcast"
light.data$haul[light.data$ctime > cast.data$downcast_start & light.data$ctime < cast.data$upcast_end[1]] <- cast.data$haul[1]
# Remove on-bottom and errant sampling not from casts
light.data <- subset(light.data, is.na(updown) == F)
return(light.data)
}
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 4))
test.vert <- subset(vert, updown == "Downcast")
test.vert <- subset(test.vert, updown == "Downcast")
test.vert
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 5))
test.vert <- subset(test.vert, updown == "Downcast")
test.vert
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 6))
test.vert <- subset(test.vert, updown == "Downcast")
test.vert
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 11))
test.vert <- subset(test.vert, updown == "Downcast")
test.vert
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 9))
test.vert <- subset(test.vert, updown == "Downcast")
test.vert
filter_stepwise <- function(profile.data, bin.size = 2, bin.gap = 6, agg.fun, ...) {
max.depth <- max(ceiling(profile.data$cdepth), na.rm = T)
# Bin by depth with bins centered
profile.data$cdepth <- findInterval(profile.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2
# # Convert light data
# profile.data$trans_llight <- convert_light(profile.data$llight)
# Calculate binned light level using user-specified function
light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = profile.data, FUN = eval(parse(text = paste(agg.fun))))
light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
# Stepwise measurement removal loop
p2 <- 1
while(p2 < nrow(light_at_depth) ) {
if(nrow(light_at_depth) >= (p2 + 1)) {
if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
light_at_depth <- light_at_depth[-p2,]
p2 <- 0 # Index back to start
}
}
p2 <- p2 + 1
}
# Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
light_at_depth$quality <- 1
} else {
light_at_depth$quality <- -999
}
return(light_at_depth)
}
filter_stepwise(test.vert, agg.fun = "median")
head(test.vert)
convert_light <- function(x) {
y <- 1*10^-8 * exp(0.1322*x)
return(y)
}
filter_stepwise <- function(profile.data, light.col, depth.col, bin.size = 2, bin.gap = 6, agg.fun, ...) {
names(x)[which(names(x) == light.col)] <- "trans_llight"
names(x)[which(names(x) == depth.col)] <- "cdepth"
max.depth <- max(ceiling(profile.data$cdepth), na.rm = T)
# Bin by depth with bins centered
profile.data$cdepth <- findInterval(profile.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2
# # Convert light data
# profile.data$trans_llight <- convert_light(profile.data$llight)
# Calculate binned light level using user-specified function
light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = profile.data, FUN = eval(parse(text = paste(agg.fun))))
light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
# Stepwise measurement removal loop
p2 <- 1
while(p2 < nrow(light_at_depth) ) {
if(nrow(light_at_depth) >= (p2 + 1)) {
if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
light_at_depth <- light_at_depth[-p2,]
p2 <- 0 # Index back to start
}
}
p2 <- p2 + 1
}
# Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
light_at_depth$quality <- 1
} else {
light_at_depth$quality <- -999
}
names(x)[which(names(x) == "optical_depth")] <- light.col
names(x)[which(names(x) == "cdepth")] <- depth.col
return(light_at_depth)
}
test.vert$trans_llight <-
filter_stepwise(test.vert, agg.fun = "median")
test.vert$trans_llight <-
filter_stepwise(x = test.vert, agg.fun = "median")
test.vert$trans_llight <-
filter_stepwise(x = test.vert, agg.fun = "median")
filter_stepwise <- function(cast.data, light.col, depth.col, bin.size = 2, bin.gap = 6, agg.fun, ...) {
names(cast.data)[which(names(cast.data) == light.col)] <- "trans_llight"
names(cast.data)[which(names(cast.data) == depth.col)] <- "cdepth"
max.depth <- max(ceiling(cast.data$cdepth), na.rm = T)
# Bin by depth with bins centered
cast.data$cdepth <- findInterval(cast.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2
# # Convert light data
# cast.data$trans_llight <- convert_light(cast.data$llight)
# Calculate binned light level using user-specified function
light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = cast.data, FUN = eval(parse(text = paste(agg.fun))))
light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
# Stepwise measurement removal loop
p2 <- 1
while(p2 < nrow(light_at_depth) ) {
if(nrow(light_at_depth) >= (p2 + 1)) {
if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
light_at_depth <- light_at_depth[-p2,]
p2 <- 0 # Index back to start
}
}
p2 <- p2 + 1
}
# Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
light_at_depth$quality <- 1
} else {
light_at_depth$quality <- -999
}
names(cast.data)[which(names(cast.data) == "optical_depth")] <- light.col
names(cast.data)[which(names(cast.data) == "cdepth")] <- depth.col
return(light_at_depth)
}
test.vert$trans_llight <-
filter_stepwise(x = test.vert, agg.fun = "median")
test.vert$trans_llight <-
filter_stepwise(cast.data = test.vert, agg.fun = "median")
filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
filter_stepwise <- function(cast.data, light.col, depth.col, bin.size = 2, bin.gap = 6, agg.fun, ...) {
names(cast.data)[which(names(cast.data) == light.col)] <- "trans_llight"
names(cast.data)[which(names(cast.data) == depth.col)] <- "cdepth"
print(names(cast.data))
max.depth <- max(ceiling(cast.data$cdepth), na.rm = T)
# Bin by depth with bins centered
cast.data$cdepth <- findInterval(cast.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2
# # Convert light data
# cast.data$trans_llight <- convert_light(cast.data$llight)
# Calculate binned light level using user-specified function
light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = cast.data, FUN = eval(parse(text = paste(agg.fun))))
light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
# Stepwise measurement removal loop
p2 <- 1
while(p2 < nrow(light_at_depth) ) {
if(nrow(light_at_depth) >= (p2 + 1)) {
if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
light_at_depth <- light_at_depth[-p2,]
p2 <- 0 # Index back to start
}
}
p2 <- p2 + 1
}
# Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
light_at_depth$quality <- 1
} else {
light_at_depth$quality <- -999
}
names(cast.data)[which(names(cast.data) == "optical_depth")] <- light.col
names(cast.data)[which(names(cast.data) == "cdepth")] <- depth.col
return(light_at_depth)
}
filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
test.vert$light_tight <- convert_light(test.vert$llight)
filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.vert)
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 10))
test.vert <- subset(test.vert, updown == "Downcast")
test.vert$light_tight <- convert_light(test.vert$llight)
head(test.vert)
filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.filter_stepwise)
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 13))
test.vert <- subset(test.vert, updown == "Downcast")
test.vert$light_tight <- convert_light(test.vert$llight)
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.filter_stepwise)
calculate_attenuation <- function(x, light.col = "trans_llight", depth.col = "cdepth", loess.criterion = "aicc", loess.degree = 1, kz.binsize = 0.2, min.range = 10, ...) {
names(x)[which(names(x) == light.col)] <- "trans_llight"
names(x)[which(names(x) == depth.col)] <- "cdepth"
# Remove profiles with only a small portion of the water column sampled
if((max(x$cdepth) - min(x$cdepth)) > min.range) {
# Fit loess model to curve
N_depths <- seq(min(min(x$cdepth)), max(x$cdepth), kz.binsize)
profile_light_loess <- loess.as2(x = x$cdepth, y = log(x$trans_llight), criterion = loess.criterion, degree = loess.degree, ...)
light_fit <- predict(profile_light_loess, newdata = N_depths)
# Output data
output <- data.frame(depth =  N_depths[1:(length(N_depths)-1)] + kz.binsize / 2,
k_aicc = diff(light_fit) /kz.binsize)
# output$vessel <- x$vessel[1]
# output$cruise <- x$cruise[1]
# output$haul <- x$haul[1]
# output$quality <- x$quality[1]
loess.fit <- data.frame(span_fit = profile_light_loess$pars$span,
nobs = profile_light_loess$n,
enp = profile_light_loess$enp,
rse = profile_light_loess$s,
smooth_trace = profile_light_loess$trace.hat,
fit_method = loess.criterion)
# loess.fit$vessel <- x$vessel[1]
# loess.fit$cruise <- x$cruise[1]
# loess.fit$haul <- x$haul[1]
# Output residuals
resids <- data.frame(residual = residuals(profile_light_loess),
log_trans_llight = log(x$trans_llight),
cdepth = x$cdepth)
# resids$vessel <- x$vessel[1]
# resids$cruise <- x$cruise[1]
# resids$haul <- x$haul[1]
output_dfs <- list(fit_atten = loess.fit, attenuation = output, fit_residuals = resids)
return(output_dfs)
}
}
head(test.filter_stepwise)
filter_stepwise <- function(cast.data, light.col, depth.col, bin.size = 2, bin.gap = 6, agg.fun, ...) {
names(cast.data)[which(names(cast.data) == light.col)] <- "trans_llight"
names(cast.data)[which(names(cast.data) == depth.col)] <- "cdepth"
max.depth <- max(ceiling(cast.data$cdepth), na.rm = T)
# Bin by depth with bins centered
cast.data$cdepth <- findInterval(cast.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2
# # Convert light data
# cast.data$trans_llight <- convert_light(cast.data$llight)
# Calculate binned light level using user-specified function
light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = cast.data, FUN = eval(parse(text = paste(agg.fun))))
light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
# Stepwise measurement removal loop
p2 <- 1
while(p2 < nrow(light_at_depth) ) {
if(nrow(light_at_depth) >= (p2 + 1)) {
if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
light_at_depth <- light_at_depth[-p2,]
p2 <- 0 # Index back to start
}
}
p2 <- p2 + 1
}
# Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
light_at_depth$quality <- 1
} else {
light_at_depth$quality <- -999
}
names(cast.data)[which(names(cast.data) == "trans_llight")] <- light.col
names(cast.data)[which(names(cast.data) == "cdepth")] <- depth.col
return(light_at_depth)
}
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.filter_stepwise)
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.filter_stepwise)
filter_stepwise <- function(cast.data, light.col, depth.col, bin.size = 2, bin.gap = 6, agg.fun, ...) {
names(cast.data)[which(names(cast.data) == light.col)] <- "trans_llight"
names(cast.data)[which(names(cast.data) == depth.col)] <- "cdepth"
max.depth <- max(ceiling(cast.data$cdepth), na.rm = T)
# Bin by depth with bins centered
cast.data$cdepth <- findInterval(cast.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2
# # Convert light data
# cast.data$trans_llight <- convert_light(cast.data$llight)
# Calculate binned light level using user-specified function
light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = cast.data, FUN = eval(parse(text = paste(agg.fun))))
light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
# Stepwise measurement removal loop
p2 <- 1
while(p2 < nrow(light_at_depth) ) {
if(nrow(light_at_depth) >= (p2 + 1)) {
if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
light_at_depth <- light_at_depth[-p2,]
p2 <- 0 # Index back to start
}
}
p2 <- p2 + 1
}
# Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
light_at_depth$quality <- 1
} else {
light_at_depth$quality <- -999
}
names(cast.data)[which(names(cast.data) == "trans_llight")] <- light.col
names(cast.data)[which(names(cast.data) == "cdepth")] <- depth.col
return(light_at_depth)
}
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.filter_stepwise)
filter_stepwise <- function(cast.data, light.col, depth.col, bin.size = 2, bin.gap = 6, agg.fun, ...) {
names(cast.data)[which(names(cast.data) == light.col)] <- "trans_llight"
names(cast.data)[which(names(cast.data) == depth.col)] <- "cdepth"
max.depth <- max(ceiling(cast.data$cdepth), na.rm = T)
# Bin by depth with bins centered
cast.data$cdepth <- findInterval(cast.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2
# # Convert light data
# cast.data$trans_llight <- convert_light(cast.data$llight)
# Calculate binned light level using user-specified function
light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = cast.data, FUN = eval(parse(text = paste(agg.fun))))
light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
# Stepwise measurement removal loop
p2 <- 1
while(p2 < nrow(light_at_depth) ) {
if(nrow(light_at_depth) >= (p2 + 1)) {
if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
light_at_depth <- light_at_depth[-p2,]
p2 <- 0 # Index back to start
}
}
p2 <- p2 + 1
}
# Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
light_at_depth$quality <- 1
} else {
light_at_depth$quality <- -999
}
names(light_at_depth)[which(names(light_at_depth) == "trans_llight")] <- light.col
names(light_at_depth)[which(names(light_at_depth) == "cdepth")] <- depth.col
return(light_at_depth)
}
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "cdepth")
head(test.filter_stepwise)
calculate_attenuation(light.col = )
calculate_attenuation(x = test.filter_stepwise, light.col = "light_tight", depth.col = "cdepth")
test.calculate_attenuation <- calculate_attenuation(x = test.filter_stepwise, light.col = "light_tight", depth.col = "cdepth")
light_proportion <- function(x, water.col = "trans_llight", depth.col = "cdepth", ...) {
names(x)[names(x) == water.col] <- "trans_llight"
names(x)[names(x) == depth.col] <-  "cdepth"
# Light ratio relative to shallowest bin.
x$light_ratio <- x$trans_llight / max(x$trans_llight, na.rm = T)
# Linear attenuation coefficient relative to shallowest bin.
x$k_linear <- log(x$trans_llight/max(x$trans_llight)) / (min(x$cdepth) - x$cdepth)
# Whole column attenuation coefficient.
x$k_column <- rep((log(min(x$trans_llight)/max(x$trans_llight))) / (min(x$cdepth) - max(x$cdepth)), nrow(x))
names(x)[names(x) == "trans_llight"] <- water.col
names(x)[names(x) == "cdepth"] <-  depth.col
return(x)
}
light_proportion <- function(x, light.col = "trans_llight", depth.col = "cdepth", ...) {
names(x)[names(x) == light.col] <- "trans_llight"
names(x)[names(x) == depth.col] <-  "cdepth"
# Light ratio relative to shallowest bin.
x$light_ratio <- x$trans_llight / max(x$trans_llight, na.rm = T)
# Linear attenuation coefficient relative to shallowest bin.
x$k_linear <- log(x$trans_llight/max(x$trans_llight)) / (min(x$cdepth) - x$cdepth)
# Whole column attenuation coefficient.
x$k_column <- rep((log(min(x$trans_llight)/max(x$trans_llight))) / (min(x$cdepth) - max(x$cdepth)), nrow(x))
names(x)[names(x) == "trans_llight"] <- light.col
names(x)[names(x) == "cdepth"] <-  depth.col
return(x)
}
light_proportion(x = test.vert, light.col = "light_tight", depth.col = "cdepth")
names(test.vert)[which(names(test.vert) == "cdepth"])]
names(test.vert)[which(names(test.vert) == "cdepth")]
names(test.vert)[which(names(test.vert) == "cdepth")] <- "z"
test.casts <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/corr_MK9hauls.csv")
test.times <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/CastTimes.csv")
test.casts$ctime <- as.POSIXct(strptime(test.casts$ctime, format = "%Y-%m-%d %H:%M:%S"))
test.times$downcast_start <- as.POSIXct(strptime(test.times$downcast_start, format = "%Y-%m-%d %H:%M:%S")) - 20
test.times$downcast_end <- as.POSIXct(strptime(test.times$downcast_end, format = "%Y-%m-%d %H:%M:%S")) + 20
test.times$upcast_start <- as.POSIXct(strptime(test.times$upcast_start, format = "%Y-%m-%d %H:%M:%S")) - 20
test.times$upcast_end <- as.POSIXct(strptime(test.times$upcast_end, format = "%Y-%m-%d %H:%M:%S")) + 20
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 13))
test.vert <- subset(test.vert, updown == "Downcast")
names(test.vert)[which(names(test.vert) == "cdepth")] <- "z"
test.vert$light_tight <- convert_light(test.vert$llight)
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "z")
head(test.filter_stepwise)
test.calculate_attenuation <- calculate_attenuation(x = test.filter_stepwise, light.col = "light_tight", depth.col = "z")
light_proportion(x = test.vert, light.col = "light_tight", depth.col = "z")
test.casts <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/corr_MK9hauls.csv")
test.times <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/CastTimes.csv")
test.casts$ctime <- as.POSIXct(strptime(test.casts$ctime, format = "%Y-%m-%d %H:%M:%S"))
require(devtools)
devtools::create("trawllight")
package?devtools
?findInterval
test.casts <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/corr_MK9hauls.csv")
test.times <- read.csv("D:/Projects/OneDrive/Thesis/Chapter 1 - Visual Foraging Condition in the Eastern Bering Sea/data/LightData/Data/year_08/ebs/v_89/CastTimes.csv")
test.casts$ctime <- as.POSIXct(strptime(test.casts$ctime, format = "%Y-%m-%d %H:%M:%S"))
test.times$downcast_start <- as.POSIXct(strptime(test.times$downcast_start, format = "%Y-%m-%d %H:%M:%S")) - 20
test.times$downcast_end <- as.POSIXct(strptime(test.times$downcast_end, format = "%Y-%m-%d %H:%M:%S")) + 20
test.times$upcast_start <- as.POSIXct(strptime(test.times$upcast_start, format = "%Y-%m-%d %H:%M:%S")) - 20
test.times$upcast_end <- as.POSIXct(strptime(test.times$upcast_end, format = "%Y-%m-%d %H:%M:%S")) + 20
test.vert <- vertical_profiles(light.data = test.casts,
cast.data = subset(test.times, haul == 13))
test.vert <- subset(test.vert, updown == "Downcast")
names(test.vert)[which(names(test.vert) == "cdepth")] <- "z"
test.vert$light_tight <- convert_light(test.vert$llight)
test.filter_stepwise <- filter_stepwise(cast.data = test.vert, agg.fun = "median", light.col = "light_tight", depth.col = "z")
head(test.filter_stepwise)
test.calculate_attenuation <- calculate_attenuation(x = test.filter_stepwise, light.col = "light_tight", depth.col = "z")
test.light_proportion <- light_proportion(x = test.vert, light.col = "light_tight", depth.col = "z")
require(roxygen2)
roxygenize(package.dir = getwd())
?data.frame
roxygenize(package.dir = getwd())
?document
document(getwd())
roxygenize(package.dir = getwd())
roxygenize(package.dir = getwd())
find.package(trawllight)
find.package(trawllight)
library(trawllight)
find.package(trawllight)
?convert_light
find.package("trawllight")
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(find.package("trawllight"))))
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(find.package("trawllight"))))
ls.all()
ls()
rm(list = ls())
require(trawllight)
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(path)))
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(find.package("trawllight"))))
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(find.package("trawllight"))))
system(paste(shQuote(file.path(R.home("bin"), "R")),"CMD", "Rd2pdf", shQuote(find.package("trawllight"))))
require(devtools)
check(find.package("trawllight"), cleanup = F)
find.package("trawllight")
R CMD
R CMD Rd2pdf
install.packages("PkgUtils")
require(PkgUtils)
library(trawllight)
?convert_light
?use_vignette
use_vignette("trawllight")
1.
1.75*5
37/2
37/2/8
37/2/10
paste("trans_llight", paste(x1, collapse = "+"), sep = "~")
?aggregate
library(trawllight)
library(trawllight)
View(filter_stepwise())
View(filter_stepwise
)
library(trawllight)
library(trawllight)
library(trawllight)
library(trawllight)
View(geometric.mean)
View(mean)
x <- c(-1,2,3)
any(x > 0)
any(x < 0)
x <- c(0,2,3)
any(x < 0)
log(0)
any(x <= 0)
?log
library(trawllight)
install.packages"TMB"
install.packages(TMB)
install.packages("TMB")
library(TMB)
runExample(all = T)
install.packages(c("plyr", "dplyr", "reshape", "reshape2", "ggplot2", "mgcv", "MASS", "fANCOVA", "roxygen2", "knitr", "vegan", "raster", "ggmap", "GGally", "gridExtra"))
library(trawllight)
library(trawllight)
library(trawllight)
