# Load necessary scripts to process data
source("redesigned_column_functions.R")
source("station_k_plot.R")
source("smooth_attenuation.R")

# Import survey data structure
survey.list <- read.csv("survey_list.csv") 
names(survey.list) <- c("year", "region", "vessel")
haul_data <- read.csv(file = "./data/BS hauls.csv")
haul_data$START_TIME <- as.POSIXct(haul_data$START_TIME, format = "%m/%d/%Y %H:%M:%S", tz = "America/Anchorage")
haul_time_position <- dplyr::select(haul_data, VESSEL, CRUISE, HAUL, START_TIME, STATIONID, START_LATITUDE, START_LONGITUDE, BOTTOM_DEPTH, PERFORMANCE, HAUL_TYPE, STRATUM)
names(haul_time_position) <- tolower(names(haul_time_position))

# Import stratification data
brunt_vaisala <- read.csv(file = "./data/CTD/output/brunt-vaisala_2008-2010.csv")
names(brunt_vaisala) <- tolower(names(brunt_vaisala))

# Import light data, bin aggregation, stepwise point removal, attenuation fitting
ebs_shelf_down_1 <- process_all(dir.structure = subset(survey.list, region == "ebs")[c(1:4),])
ebs_shelf_down_2 <- process_all(dir.structure = subset(survey.list, region == "ebs")[c(5:6),])
ebs_shelf_down_3 <- process_all(dir.structure = subset(survey.list, region == "ebs")[c(7:10),])
ebs_shelf_down_4 <- process_all(dir.structure = subset(survey.list, region == "ebs")[c(11:14),])
ebs_shelf_down_5 <- process_all(dir.structure = subset(survey.list, region == "ebs")[c(15:18),])
ebs_shelf_down_6 <- process_all(dir.structure = subset(survey.list, region == "ebs")[c(19:22),])
ebs_shelf_down_7 <- process_all(dir.structure = subset(survey.list, region == "ebs")[c(23:24),])
ebs_shelf_down_8 <- process_all(dir.structure = subset(survey.list, region == "ebs")[c(25:26),])

# Import surface data during casts
ebs_surface1 <- process_all_surface(surveys = subset(survey.list, region == "ebs")[5:10,]) # No surface data from 2004 & 2005
ebs_surface2 <- process_all_surface(surveys = subset(survey.list, region == "ebs")[11:16,])
ebs_surface3 <- process_all_surface(surveys = subset(survey.list, region == "ebs")[17:24,])
ebs_surface4 <- process_all_surface(surveys = subset(survey.list, region == "ebs")[25:26,])
surface_measurements <- rbind(ebs_surface1, ebs_surface2, ebs_surface3, ebs_surface4)
surface_measurements <- subset(surface_measurements, updown == "Downcast")

# Remove vessel/cruise combinations with obstructed surface light meter
surface_measurements <- subset(surface_measurements, !(vessel == 162 & cruise == 201101)) # Obstructed
surface_measurements <- subset(surface_measurements, !(vessel == 134 & cruise == 200601)) # Obstructed
surface_measurements <- subset(surface_measurements, !(vessel == 94 & cruise == 201401)) # Obstructed
surface_measurements <- subset(surface_measurements, !(vessel == 94 & cruise == 201501)) # Obstructed

# Detect obstruction using indirect method. 
light_ratios <- rbind(ebs_shelf_down_1$light_ratios, 
      ebs_shelf_down_2$light_ratios, 
      ebs_shelf_down_3$light_ratios,
      ebs_shelf_down_4$light_ratios,
      ebs_shelf_down_5$light_ratios,
      ebs_shelf_down_6$light_ratios,
      ebs_shelf_down_7$light_ratios,
      ebs_shelf_down_8$light_ratios)

# Detect obstruction using indirect method
indirect.df <- tag_indirect_loop(merge(light_ratios, haul_time_position), depth.bins = c(1,3,5), utc.offset = -8, dark.adjust = 0.001, lat.col = "start_latitude", lon.col = "start_longitude", time.col = "start_time", light.col = "trans_llight")

# Detect obstruction using direct method
direct.df <- tag_residuals_direct(x = merge(light_ratios, select(surface_measurements, vessel, cruise, haul, updown, surf_trans_llight)), formula = log10(trans_llight) ~ log10(surf_trans_llight) + interaction(vessel, cruise), water.col = "trans_llight", surface.col = "surf_trans_llight", depth.col = "cdepth", depth.bins = c(1, 3, 5))

# Compare residuals between methods: sea_state_model_selection.R

# Combine orientation methods with cut-off: plot_orientation_threshold.R
orientation.indirect <- assign_orientation(x = indirect.df, resid.col = "light_residual", resid.cut = -0.81, name.orientation = "indirect_orientation")
orientation.direct <- assign_orientation(x = direct.df, resid.col = "direct_residual", resid.cut = -0.85, name.orientation = "direct_orientation")
orientation.combined <- merge(orientation.indirect, orientation.direct, all = T)
orientation.combined <- unique(select(orientation.combined, vessel, cruise, haul, updown, quality, indirect_orientation, direct_orientation))

# Assign orientation using a priori rules for designating bad casts
orientation.combined$orientation <- "Bad"
orientation.combined$orientation[orientation.combined$indirect_orientation == "Good"] <- "Good"
orientation.combined$orientation[orientation.combined$direct_orientation == "Good"] <- "Good"
orientation.combined$orientation[orientation.combined$direct_orientation == "Bad"] <- "Bad"

# Estimate near-surface light for missing measurements
light_ratios_interp <- cast_wrapper(light_ratios, FUN = "estimate_surface")

# Evaluate performance of interpolation method: "interpolation_performance_evaluation.R"

# Calculate optical depth
light_ratios_interp$optical_depth_z <- log(1) - log(light_ratios_interp$light_ratio)

# Append OD 2.303 (10% light level)
light_ratios_interp <- merge(light_ratios_interp, cast_wrapper(select(light_ratios_interp, vessel, cruise, haul, cdepth, optical_depth_z), FUN = "find_optical_depth", light.level = 0.1, return.col = "z_od10", od.col = "optical_depth_z"))

# Append OD 4.606 (1% light level)
light_ratios_interp <- merge(light_ratios_interp, cast_wrapper(select(light_ratios_interp, vessel, cruise, haul, cdepth, optical_depth_z), FUN = "find_optical_depth", light.level = 0.01, return.col = "z_od1", od.col = "optical_depth_z"))

# Attenuation lower 20 m
light_ratios_interp <- merge(light_ratios_interp, cast_wrapper(lr.in = light_ratios_interp, depth.interval = "nearbottom", depth.absolute = 20, FUN = "attenuation_interval", depth.col = "cdepth", light.col = "trans_llight", return.col = "k_lower_20m"))

# Attenuation lower 20%
light_ratios_interp <- merge(light_ratios_interp, cast_wrapper(lr.in = light_ratios_interp, depth.interval = "nearbottom", depth.proportion = 20, FUN = "attenuation_interval", depth.col = "cdepth", light.col = "trans_llight", return.col = "k_lower_20pct"))

# Merge orientation to optical depth
light_ratios_interp <- merge(light_ratios_interp, dplyr::select(orientation.combined, vessel, cruise, haul, orientation))

# Combine column variables for analyses
whole.column.vars <- merge(light_ratios_interp, orientation.combined) # Include archival tag orientation
whole.column.vars <- merge(whole.column.vars, haul_time_position) # Include haul data
whole.column.vars$column_od <- whole.column.vars$k_column * whole.column.vars$bottom_depth
whole.column.vars <- select(whole.column.vars, vessel, cruise, haul, quality, k_column, orientation, z_od1, z_od10, column_od, k_lower_20m, k_lower_20pct)
whole.column.vars <- unique(whole.column.vars)


whole.column.vars <- full_join(whole.column.vars, interpolated_od) # Include interpolated OD surface
whole.column.vars$optical_depth <- whole.column.vars$column_od
whole.column.vars$optical_depth[is.na(whole.column.vars$column_od)] <- whole.column.vars$OD_interpolated[is.na(whole.column.vars$column_od)]
whole.column.vars$optical_depth[whole.column.vars$orientation == "Bad" | is.na(whole.column.vars$orientation)] <- whole.column.vars$OD_interpolated[whole.column.vars$orientation == "Bad" | is.na(whole.column.vars$orientation)]
whole.column.vars$optical_depth[whole.column.vars$quality == -999 | is.na(whole.column.vars$quality)] <- whole.column.vars$OD_interpolated[whole.column.vars$quality == -999 | is.na(whole.column.vars$quality)]

# Spatially interpolate near-bottom optical depth: spatial.R
# Spatially interpolate depths of 10% and 1% light: 'od_depths.R'
head(light_ratios_interp)
head(orientation.combined)
profile.vars <- select(merge(light_ratios_interp, orientation.combined), vessel, cruise, haul, cdepth, trans_llight, light_ratio, k_linear, optical_depth_z, orientation, quality)

attenuation.vars <- rbind(ebs_shelf_down_1$atten_values, 
                        ebs_shelf_down_2$atten_values, 
                        ebs_shelf_down_3$atten_values,
                        ebs_shelf_down_4$atten_values,
                        ebs_shelf_down_5$atten_values,
                        ebs_shelf_down_6$atten_values,
                        ebs_shelf_down_7$atten_values,
                        ebs_shelf_down_8$atten_values)
attenuation.vars$k_aicc <- attenuation.vars$k_aicc*-1
attenuation.vars <- inner_join(select(attenuation.vars, vessel, cruise, haul, depth, k_aicc, quality), select(orientation.combined, vessel, cruise, haul, orientation))

### Smooth attenuation profiles for plotting
attenuation.vars <- smooth_attenuation(av = attenuation.vars)

# EBS shelf survey area stations with summary statistics: shelf_survey_stations.R


# write.csv(whole.column.vars, file = paste("./output/column_vars_",Sys.Date(),".csv", sep = ""), row.names = F)
# write.csv(profile.vars, file = paste("./output/light_vs_depth_vars_", Sys.Date(), ".csv", sep = ""), row.names = F)
# write.csv(attenuation.vars, file = paste("./output/attenuation_profiles_", Sys.Date(), ".csv", sep = ""), row.names = F)


ggplot(test2, aes(x = light_residual, fill = factor(vessel))) + geom_histogram() + geom_vline(aes(xintercept = 0)) + facet_wrap(~cruise + vessel)

ggplot(data = merge(test2, sea_state), aes(x = factor(hour(start_time)), y = light_residual)) + geom_violin()
ggplot(data = merge(test2, sea_state), aes(x = cut(EDIT_WIND_SPEED, breaks = c(0,10,20,30,40)), y = light_residual)) + geom_violin()
ggplot(data = merge(test2, sea_state), aes(x = cut(EDIT_WAVE_HEIGHT, breaks = c(0,1,3,6,13)), y = light_residual)) + geom_violin()

ggplot(data = merge(test2, sea_state), aes(x = EDIT_WIND_SPEED, y = light_residual)) + geom_point() + geom_quantile()
mean(sea_state$EDIT_SWELL_HEIGHT)


# How many missing surface measurements? missing_surface_measurements.R