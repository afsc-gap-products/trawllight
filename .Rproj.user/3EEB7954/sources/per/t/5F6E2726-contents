require(mgcv)
require(fishmethods)
require(ggplot2)
require(gridExtra)
require(scales)
require(plyr)
require(reshape)
require(MASS)
require(lubridate)
require(fields)
require(ggthemes)
require(plotly)
require(dplyr)
require(data.table)
require(maptools)
require(colorspace)
require(ggmap)
require(geoR)
require(spatstat)
require(gstat)
require(raster)
require(rgdal)
require(raster)
require(dismo) # for k-fold cross validation
require(fifer)
require(factoextra)
require(fANCOVA)
require(rasterVis)
require(sf)
require(viridis)
require(quantreg)
require(prettymapr)

#===================================================#
# STEP 1: Generate vertical profiles                #
#===================================================#
vertical_profiles <- function(light.data, cast.data, ...) {

  # Remove surface data
  light.data <- subset(light.data, cdepth >= 0)
  
  # Create empty columns for cast direction (updown) and haul number
  light.data$updown <- rep(NA, nrow(light.data))
  light.data$haul <- rep(NA, nrow(light.data))

    # Assign upcast or downcast to times
    light.data$updown[light.data$ctime > cast.data$downcast_start & light.data$ctime < cast.data$downcast_end[1]] <- "Downcast"
    light.data$updown[light.data$ctime > cast.data$upcast_start & light.data$ctime < cast.data$upcast_end[1]] <- "Upcast"
    light.data$haul[light.data$ctime > cast.data$downcast_start & light.data$ctime < cast.data$upcast_end[1]] <- cast.data$haul[1]

  # Remove on-bottom and errant sampling not from casts
  light.data <- subset(light.data, is.na(updown) == F)
  return(light.data)
}



#===================================================#
# STEP 2: Stepwise removal based on expectation     #
# that light should decrease with depth             #
#===================================================#
filter_stepwise <- function(profile.data, bin.size = 2, bin.gap = 6, agg.fun, ...) {
    max.depth <- max(ceiling(profile.data$cdepth), na.rm = T)
    # Bin by depth with bins centered
    profile.data$cdepth <- findInterval(profile.data$cdepth, seq(0, max.depth, bin.size), rightmost.closed = T, left.open = F) * bin.size - bin.size/2 
  
  # # Convert light data
  # profile.data$trans_llight <- convert_light(profile.data$llight)
  
  # Calculate binned light level using user-specified function
  light_at_depth <- aggregate(trans_llight ~ vessel + cruise + haul + updown + cdepth, data = profile.data, FUN = eval(parse(text = paste(agg.fun))))
  light_at_depth <- light_at_depth[order(light_at_depth$cdepth),]
  # Stepwise measurement removal loop  
    p2 <- 1
    while(p2 < nrow(light_at_depth) ) {
      if(nrow(light_at_depth) >= (p2 + 1)) {
        if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
          light_at_depth <- light_at_depth[-p2,]
          p2 <- 0 # Index back to start
        }
      }
      p2 <- p2 + 1
    }
    # Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
    
    # light_at_depth$quality <- max(diff(light_at_depth$cdepth))
    
    if(max(diff(light_at_depth$cdepth)) <= bin.gap & min(light_at_depth$cdepth + 1) <= bin.gap) {
      light_at_depth$quality <- 1
    } else {
      light_at_depth$quality <- -999
    }
    
  return(light_at_depth)
}


#===================================================#
# STEP 3: Calculate depth-specific attenuation for  #
# each haul                                         #
#===================================================#

calculate_attenuation <- function(x, loess.criterion = "aicc", loess.degree = 1, kz.binsize = 0.2, min.range = 10, ...) {
  # Remove profiles with only a small portion of the water column sampled
  
  if((max(x$cdepth) - min(x$cdepth)) > min.range) {
    
    # Fit loess model to curve
    N_depths <- seq(min(min(x$cdepth)), max(x$cdepth), kz.binsize)
    profile_light_loess <- loess.as2(x = x$cdepth, y = log(x$trans_llight), criterion = loess.criterion, degree = loess.degree)
    light_fit <- predict(profile_light_loess, newdata = N_depths)
    
    # Output data
    output <- data.frame(depth =  N_depths[1:(length(N_depths)-1)] + kz.binsize / 2,
                         k_aicc = diff(light_fit) /kz.binsize)
    
    output$vessel <- x$vessel[1]
    output$cruise <- x$cruise[1]
    output$haul <- x$haul[1]
    output$quality <- x$quality[1]
    
    loess.fit <- data.frame(span_fit = profile_light_loess$pars$span,
                            nobs = profile_light_loess$n,
                            enp = profile_light_loess$enp,
                            rse = profile_light_loess$s,
                            smooth_trace = profile_light_loess$trace.hat,
                            fit_method = loess.criterion)
    loess.fit$vessel <- x$vessel[1]
    loess.fit$cruise <- x$cruise[1]
    loess.fit$haul <- x$haul[1]
    
    # Output residuals
    resids <- data.frame(residual = residuals(profile_light_loess),
                         log_trans_llight = log(x$trans_llight),
                         cdepth = x$cdepth)
    resids$vessel <- x$vessel[1]
    resids$cruise <- x$cruise[1]
    resids$haul <- x$haul[1]
    
    output_dfs <- list(fit_atten = loess.fit, attenuation = output, fit_residuals = resids)
    return(output_dfs)
  }
}

#===================================================#
# STEP 4: Calculate light ratios for optical depth  #
# calculations and dynamic light environment models #
#===================================================#
light_proportion <- function(x, water.col = "trans_llight", depth.col = "cdepth", ...) {
  
    names(x)[names(x) == water.col] <- "trans_llight"
    names(x)[names(x) == depth.col] <-  "cdepth"
    # Light ratio relative to shallowest bin.
    x$light_ratio <- x$trans_llight / max(x$trans_llight, na.rm = T)
    
    # Linear attenuation coefficient relative to shallowest bin.
    x$k_linear <- log(x$trans_llight/max(x$trans_llight)) / (min(x$cdepth) - x$cdepth)
    
    # Whole column attenuation coefficient.
    x$k_column <- rep((log(min(x$trans_llight)/max(x$trans_llight))) / (min(x$cdepth) - max(x$cdepth)), nrow(x))
    names(x)[names(x) == "trans_llight"] <- water.col
    names(x)[names(x) == "cdepth"] <-  depth.col
  return(x)
}

#===================================================#
# Light conversion (Kotwicki et al. 2009)           #
#===================================================#
convert_light <- function(x) {
  y <- 1*10^-8 * exp(0.1322*x)
  return(y)
}

#===================================================#
# Wrapper function for all of the code              #
#===================================================#
process_all <- function(dir.structure, time.buffer = 20, updown = "Downcast", agg.fun = "median", binsize = 2, bin.gap = 6, kz.binsize = 0.5, ...) {
  loess_eval <- 1
  for(i in 1:nrow(dir.structure)) {
    # Step 1. Input directory and CastTimes and corr_MK9_hauls files
    corr_mk9hauls <- read.csv(paste("./data/LightData/Data/", dir.structure$year[i],"/", dir.structure$region[i],"/",dir.structure$vessel[i],"/corr_MK9hauls.csv", sep = ""))
    casttimes <- read.csv(paste("./data/LightData/Data/", dir.structure$year[i],"/",dir.structure$region[i],"/",dir.structure$vessel[i],"/CastTimes.csv", sep = ""))

    corr_mk9hauls$ctime <- as.POSIXct(strptime(corr_mk9hauls$ctime, format = "%Y-%m-%d %H:%M:%S"))
    casttimes$downcast_start <- as.POSIXct(strptime(casttimes$downcast_start, format = "%Y-%m-%d %H:%M:%S")) - time.buffer
    casttimes$downcast_end <- as.POSIXct(strptime(casttimes$downcast_end, format = "%Y-%m-%d %H:%M:%S")) + time.buffer
    casttimes$upcast_start <- as.POSIXct(strptime(casttimes$upcast_start, format = "%Y-%m-%d %H:%M:%S")) - time.buffer 
    casttimes$upcast_end <- as.POSIXct(strptime(casttimes$upcast_end, format = "%Y-%m-%d %H:%M:%S")) + time.buffer
    
    for(j in 1:nrow(casttimes)) {
      vert <- vertical_profiles(light.data = corr_mk9hauls, 
                                cast.data = subset(casttimes, haul == casttimes$haul[j]))
      vert <- subset(vert, updown == "Downcast")
      if(nrow(vert) > 0) {
        vert$trans_llight <- convert_light(vert$llight)
        filtered <- filter_stepwise(profile.data = vert, binsize = binsize, bin.gap = bin.gap, agg.fun = agg.fun)
        atten.out <- calculate_attenuation(filtered, kz.binsize = kz.binsize)
        
        if(nrow(atten.out$output) > 1) {
          atten.out$attenuation$vessel <- vert$vessel[1]
          atten.out$attenuation$cruise <- vert$cruise[1]
          atten.out$attenuation$haul <- vert$haul[1]
          atten.out$attenuation$quality <- vert$quality[1]
          
          atten.out$fit_atten$vessel <- vert$vessel[1]
          atten.out$fit_atten$cruise <- vert$cruise[1]
          atten.out$fit_atten$haul <- vert$haul[1]
          
          atten.out$fit_residuals$vessel <- vert$vessel[1]
          atten.out$fit_residuals$cruise <- vert$cruise[1]
          atten.out$fit_residuals$haul <- vert$haul[1]
        
        }
        
        lr.out <- light_proportion(filtered)
        
        if(class(loess_eval) == "numeric") {
          loess_eval <- atten.out$fit_atten
          atten_values <- atten.out$attenuation
          resid_fit <- atten.out$fit_residuals
          light_ratios <- lr.out
        } else{
          loess_eval <- rbind.fill(loess_eval, atten.out$fit_atten)
          resid_fit <- rbind.fill(resid_fit, atten.out$fit_residuals)
          atten_values <- rbind.fill(atten_values, atten.out$attenuation)
          light_ratios <- rbind.fill(light_ratios, lr.out)
        }
      }
    }
  }
  return(list(loess_eval = loess_eval, atten_values = atten_values, light_ratios = light_ratios, resid_fit = resid_fit))
}


#============================================#
# Functions to detect tag orientation errors #
#============================================#

### Indirect method ###
# utc.offset = Time zone offset relative to UTC
tag_residuals_indirect <- function(x, utc.offset = -8, lat.col = "start_latitude", lon.col = "start_longitude", time.col = "start_time", light.col = "trans_llight") {
  
  # Change column names to match processing
  names(x)[names(x) == lat.col] <- "start_latitude"
  names(x)[names(x) == lon.col] <- "start_longitude"
  names(x)[names(x) == time.col] <- "start_time"
  names(x)[names(x) == light.col] <- "trans_llight"

  x$hhour <- hour(x$start_time) + minute(x$start_time)/60
  
  x <- cbind(x, astrocalc4r(day = day(x$start_time), month = month(x$start_time), year = year(x$start_time), hour = hour(x$start_time) + minute(x$start_time)/60, timezone = rep(-8, nrow(x)), lat = x$start_latitude, lon = x$start_longitude, seaorland = "maritime"))

  x$PAR <- x$PAR

  # GAM relating Frounin et al. (1989) model output to light in a depth bin.
  LIGHT_GAM <- gam(log10(trans_llight) ~ s(PAR) + s(zenith), family = gaussian(link = "log"), data = x)
  x$light_residual <- residuals(LIGHT_GAM)
  
  # Change column names to match input
  names(x)[names(x) == "start_latitude"] <- lat.col
  names(x)[names(x) == "start_longitude"] <-  lon.col
  names(x)[names(x) == "start_time"] <-  time.col
  names(x)[names(x) == "trans_llight"] <-  light.col
  
  return(x)
}


#----------------------------------------------------
### Function to iterate over depth bins to calculate residuals
tag_indirect_loop <- function(x, depth.bins = c(1, 3, 5), ...) {
  for(i in 1:length(depth.bins)) {
  x_sub <- subset(x, cdepth == depth.bins[i])
  if(i == depth.bins[1]) {
    output.df <- tag_residuals_indirect(x_sub)
  } else {
    output.df <- rbind(output.df, tag_residuals_indirect(x_sub))
  }
  }
  return(output.df)
}

### Direct method ###
# Fits a linear model to the relationship between surface light measurements and near-surface light measurements. An interaction term between vessel and cruise is included because the relative position of the archival tags differs between vessels and surveys.
tag_residuals_direct <- function(x, formula = log10(trans_llight) ~ log10(surf_trans_llight) + interaction(vessel, cruise), water.col = "trans_llight", surface.col = "surf_trans_llight", depth.col = "cdepth", depth.bins = c(1, 3, 5, 7, 9), ...) {
  names(x)[names(x) == water.col] <- "trans_llight"
  names(x)[names(x) == surface.col] <- "surf_trans_llight"
  names(x)[names(x) == depth.col] <- "cdepth"
  for(i in 1:length(depth.bins)) {
    x_sub <- subset(x, cdepth == depth.bins[i])
    
    # Linear regression
    DIRECT_LM <- lm(formula, data = x_sub)
    
    # Append lin. reg. residuals to subset data frame
    x_sub$direct_residual <- residuals(DIRECT_LM)
    if(depth.bins[1] == depth.bins[i]) {
      output.df <- x_sub
    } else {
      output.df <- rbind.fill(output.df, x_sub)
    }
    
    names(x)[names(x) == "trans_llight"] <- water.col
    names(x)[names(x) == "surf_trans_llight"] <- surface.col
    names(x)[names(x) == "cdepth"] <- depth.col
  }
  return(output.df)
}



#================================================================================#
# loess fitting fuction modified from package fANCOVA to allow dynamic span size #
#================================================================================#
loess.as2 <- function (x, y, degree = 1, criterion = c("aicc", "gcv"), family = c("gaussian", "symmetric"), user.span = NULL, min.bins = 3, plot = FALSE, ...) 
{
  span.min <- min.bins/length(x) # Minimum observations
  criterion <- match.arg(criterion)
  family <- match.arg(family)
  x <- as.matrix(x)
  if ((ncol(x) != 1) & (ncol(x) != 2)) 
    stop("The predictor 'x' should be one or two dimensional!!")
  if (!is.numeric(x)) 
    stop("argument 'x' must be numeric!")
  if (!is.numeric(y)) 
    stop("argument 'y' must be numeric!")
  if (any(is.na(x))) 
    stop("'x' contains missing values!")
  if (any(is.na(y))) 
    stop("'y' contains missing values!")
  if (!is.null(user.span) && (length(user.span) != 1 || !is.numeric(user.span))) 
    stop("argument 'user.span' must be a numerical number!")
  if (nrow(x) != length(y)) 
    stop("'x' and 'y' have different lengths!")
  if (length(y) < 3) 
    stop("not enough observations!")
  data.bind <- data.frame(x = x, y = y)
  if (ncol(x) == 1) {
    names(data.bind) <- c("x", "y")
  }
  else {
    names(data.bind) <- c("x1", "x2", "y")
  }
  opt.span <- function(model, criterion = c("aicc", "gcv"), 
                       span.range = c(span.min, 1)) { # span range
    as.crit <- function(x) {
      span <- x$pars$span
      traceL <- x$trace.hat
      sigma2 <- sum(x$residuals^2)/(x$n - 1)
      aicc <- log(sigma2) + 1 + 2 * (2 * (traceL + 1))/(x$n - 
                                                          traceL - 2)
      gcv <- x$n * sigma2/(x$n - traceL)^2
      result <- list(span = span, aicc = aicc, gcv = gcv)
      return(result)
    }
    criterion <- match.arg(criterion)
    fn <- function(span) {
      mod <- update(model, span = span)
      as.crit(mod)[[criterion]]
    }
    result <- optimize(fn, span.range)
    return(list(span = result$minimum, criterion = result$objective))
  }
  if (ncol(x) == 1) {
    if (is.null(user.span)) {
      fit0 <- loess(y ~ x, degree = degree, family = family, 
                    data = data.bind, ...)
      span1 <- opt.span(fit0, criterion = criterion)$span
    }
    else {
      span1 <- user.span
    }
    fit <- loess(y ~ x, degree = degree, span = span1, family = family, 
                 data = data.bind, ...)
  }
  else {
    if (is.null(user.span)) {
      fit0 <- loess(y ~ x1 + x2, degree = degree, family = family, 
                    data.bind, ...)
      span1 <- opt.span(fit0, criterion = criterion)$span
    }
    else {
      span1 <- user.span
    }
    fit <- loess(y ~ x1 + x2, degree = degree, span = span1, 
                 family = family, data = data.bind, ...)
  }
  if (plot) {
    if (ncol(x) == 1) {
      m <- 100
      x.new <- seq(min(x), max(x), length.out = m)
      fit.new <- predict(fit, data.frame(x = x.new))
      plot(x, y, col = "lightgrey", xlab = "x", ylab = "m(x)", 
           ...)
      lines(x.new, fit.new, lwd = 1.5, ...)
    }
    else {
      m <- 50
      x1 <- seq(min(data.bind$x1), max(data.bind$x1), len = m)
      x2 <- seq(min(data.bind$x2), max(data.bind$x2), len = m)
      x.new <- expand.grid(x1 = x1, x2 = x2)
      fit.new <- matrix(predict(fit, x.new), m, m)
      persp(x1, x2, fit.new, theta = 40, phi = 30, ticktype = "detailed", 
            xlab = "x1", ylab = "x2", zlab = "y", col = "lightblue", 
            expand = 0.6)
    }
  }
  return(fit)
}
#===================================================#
#                        END                        #
#===================================================#


#===================================================#
# IMPORT AND PREPARE SURFACE LIGHT DATA             #
# Similar to vertical_profiles()                    #
#===================================================#
surface_light <- function(light.file, cast.file, time.buffer = 40, ...) {
  light_data <- read.csv(light.file, header = F)
  light_data$ctime <- paste(light_data[,1], light_data[,2], sep = " ")
  cast_data <- read.csv(cast.file)
  # Convert cast times to POSIXct format, add 30 second offset to each cast time to avoid truncating cast data
  cast_data$downcast_start <- as.POSIXct(strptime(cast_data$downcast_start, format = "%Y-%m-%d %H:%M:%S", tz = "America/Anchorage")) - time.buffer 
  cast_data$downcast_end <- as.POSIXct(strptime(cast_data$downcast_end, format = "%Y-%m-%d %H:%M:%S", tz = "America/Anchorage")) +  time.buffer 
  cast_data$upcast_start <- as.POSIXct(strptime(cast_data$upcast_start, format = "%Y-%m-%d %H:%M:%S", tz = "America/Anchorage")) - time.buffer  
  cast_data$upcast_end <- as.POSIXct(strptime(cast_data$upcast_end, format = "%Y-%m-%d %H:%M:%S", tz = "America/Anchorage")) + time.buffer 
  
  # Convert light data to POSIXct format
  light_data$ctime <- as.POSIXct(strptime(light_data$ctime, format = "%m/%d/%Y %H:%M:%S", tz = "America/Anchorage"))
  
  # Corrections for tags set to the wrong time zone
  if(year(cast_data$downcast_start[1]) == 2016) {
    print("Correcting 2016")
    light_data$ctime <- light_data$ctime + 3600
  } else if(cast_data$vessel[1] == 162 & cast_data$cruise[1] == 201101) {
    print("Correcting 162-201101")
    light_data$ctime <- light_data$ctime + (3600*8)
  }
  
  # Select and rename light and time columns
  light_data <- light_data[,5:6]
  colnames(light_data) <- c("surf_llight", "ctime")
  light_data$surf_trans_llight <- convert_light(light_data$surf_llight)
  light_data$vessel <- rep(cast_data$vessel[1], nrow(light_data))
  light_data$cruise <- rep(cast_data$cruise[1], nrow(light_data))
  # Create empty rows for cast direction (updown) and haul number
  haul_count <- nrow(cast_data)
  for(i in 1:haul_count) {
    # Assign upcast or downcast to tag time
    light_data$updown[light_data$ctime > cast_data$downcast_start[i] & light_data$ctime < cast_data$downcast_end[i]] <- "Downcast"
    light_data$updown[light_data$ctime > cast_data$upcast_start[i] & light_data$ctime < cast_data$upcast_end[i]] <- "Upcast"
    light_data$haul[light_data$ctime > cast_data$downcast_start[i] & light_data$ctime < cast_data$upcast_end[i]] <- cast_data$haul[i]
  }
  # Remove on-bottom and errant sampling not from casts
  light_data <- subset(light_data, is.na(updown) == F)
  
  # Geometric mean and geometric standard deviation surface light during casts
  light_data_casts <- aggregate(surf_trans_llight ~ haul + updown + vessel + cruise, data = light_data, FUN = geometric.mean)
  light_cast_stdev <- aggregate(surf_trans_llight ~ haul + updown + vessel + cruise, data = light_data, FUN = geometric.sd)
  colnames(light_cast_stdev)[5] <- "sd_surf_trans_llight"
  light_cast_times <- aggregate(ctime ~ haul + updown + vessel + cruise, data = light_data, FUN = mean)
  light_cast_times$ctime <- with_tz(light_cast_times$ctime, tzone = "America/Anchorage")
  light_data_casts <- merge(light_data_casts, light_cast_stdev)
  light_data_casts <- merge(light_data_casts, light_cast_times)
  return(light_data_casts)
}
#===================================================#
#                        END                        #
#===================================================#

#=======================================================================#
# FUNCTION TO ASSIGN TAG ORIENTAITON CODES WITH USER-SPECIFIED CUT-OFFS #
#=======================================================================#
assign_orientation <- function(x, formula = vessel + cruise + haul ~ cdepth, resid.col, resid.cut, name.orientation = FALSE) {
  x.cast <- cast(x, formula, value = resid.col)
  x.cast$orientation <- "Bad"
  
  n.iter <- length(unique(x$cdepth))
  last.col <- ncol(x.cast) - n.iter
  
  if(length(resid.cut) > 1) {
    resid.cut <- rev(resid.cut)
  } else {
    resid.cut <- rep(resid.cut, n.iter)
  }
  
  iter.count <- 1
  for(i in (ncol(x.cast)-1):last.col){
    x.cast$orientation[x.cast[,i] > resid.cut[iter.count]] <- "Good"
    iter.count <- iter.count + 1
  }
  
  if(name.orientation != F) {
    names(x.cast)[ncol(x.cast)] <- name.orientation
  }
  
  x.out <- merge(x, unique(x.cast[, c(1:(ncol(x.cast)-n.iter-1), ncol(x.cast))]))
  
  return(x.out)
}
#===================================================#
#                        END                        #
#===================================================#


# Back-calculate light ratios to surface
estimate_surface <- function(x, atten.col = "k_linear", ratio.col = "light_ratio", light.col = "trans_llight", depth.col = "cdepth", id.col = c("vessel", "cruise", "haul", "updown", "quality", "k_column")) {
  if(min(x$cdepth) != 1 & nrow(x) > 3) {
  names(x)[which(names(x) == ratio.col)] <- "light_ratio"
  names(x)[which(names(x) == atten.col)] <- "k_linear"
  names(x)[which(names(x) == depth.col)] <- "cdepth"
  names(x)[which(names(x) == light.col)] <- "trans_llight"
  
  do.not.duplicate <- c(id.col, "light_ratio", "k_linear", "cdepth")
  
    x.light_ratio_adjust <- x[which(x$cdepth == min(x$cdepth)),]
    x.light_ratio_adjust$k_linear <- mean(x$k_linear[which(rank(x$cdepth) == 2)], x$k_linear[which(rank(x$cdepth) == 3)])
    rank1_depth <- x$cdepth[which(rank(x$cdepth) == 1)]
    
    bin.adjust <- min(diff(x$cdepth))/2
    
    # Calculate light ratio relative to depth for the middle of the bin
    x.light_ratio_adjust$light_ratio <- 1/exp(-1 * x.light_ratio_adjust$k_linear * (rank1_depth - bin.adjust))
    x.light_ratio_adjust[,which(!(names(x.light_ratio_adjust) %in% do.not.duplicate))] <- NA
    x.light_ratio_adjust$cdepth <- 1
    x.light_ratio_adjust$trans_llight <- x$trans_llight[which(rank(x$cdepth) == 1)] * x.light_ratio_adjust$light_ratio
    x <- rbind(x, x.light_ratio_adjust)
    x$light_ratio <- x$light_ratio / max(x$light_ratio)

    names(x)[which(names(x) == "light_ratio")] <- ratio.col
    names(x)[which(names(x) == "k_linear")] <- atten.col
    names(x)[which(names(x) == "cdepth")] <- depth.col
    names(x)[which(names(x) == "trans_llight")] <- light.col
    
  }
  return(x)

}

#======================================================================#
# Function to estimate water column depth of a specified optical depth #
#======================================================================#
find_optical_depth <- function(x, od.col = "optical_depth", depth.col = "cdepth", light.level = 0.1, return.col = F) {
  names(x)[which(names(x) == od.col)] <- "optical_depth"
  names(x)[which(names(x) == depth.col)] <- "cdepth"
  
  if(nrow(x) > 4) {
    od_in <- x$optical_depth
    x.loess <- loess.as2(x = od_in, y = log(x$cdepth), criterion = "aicc")
    x$output <- exp(predict(x.loess, newdata = -log(light.level)))
  } 
  
  if(return.col != F) {
    names(x)[ncol(x)] <- return.col 
  }
  names(x)[which(names(x) == "optical_depth")] <- od.col
  names(x)[which(names(x) == "cdepth")] <- depth.col
  
  return(x)
}
#===================================================#
#                     END                           #
#===================================================#

#============================#
# Iterative wrapper function #
#============================#
cast_wrapper <- function(lr.in, FUN, min.rows = 4, ...) {
  lr.in$id.col <- paste(lr.in$vessel, lr.in$cruise, lr.in$haul)
  unique_ids <- unique(lr.in$id.col)
  
  for(i in 1:length(unique_ids)) {
    
    EEE <- subset(lr.in, id.col == unique_ids[i])
    EEE.out <- do.call(FUN, args = list(x = EEE, ...))
    
    if(i == 1) {
      output.df <- EEE.out
    } else {
      output.df <- rbind.fill(output.df, EEE.out)
    }

  if(i %% 1000 == 0) {
    print(i)
    }
  }
  output.df <- output.df[,-which(names(output.df) == "id.col")]
  return(output.df)
}
#============================#
#             END            #
#============================#

#===========================================================#
# Function to calculate attenuation within a depth interval #
#===========================================================#
attenuation_interval <- function(x, depth.interval = "nearbottom", depth.proportion = F, depth.absolute = F, depth.col, light.col, return.col = F) {
  
    names(x)[which(names(x) == light.col)] <- "light"
    names(x)[which(names(x) == depth.col)] <- "cdepth"
    
    if(depth.interval == "nearbottom" & (depth.proportion == F & is.numeric(depth.absolute) == T)) {
      depth.interval <- c(max(x$cdepth), max(x$cdepth - depth.absolute))
    } else if(depth.interval == "nearbottom" & is.numeric(depth.proportion) == T) {
      depth.interval <- c(max(x$cdepth), max(x$cdepth * (1 - depth.proportion)))
    } else {
      stop("Error: Must specify depth.interval and either depth.proportion or depth.absolute.")
    }
    
    upper.depth <- mean(x$cdepth[which(abs(x$cdepth-min(depth.interval)) == min(abs(x$cdepth-min(depth.interval))))])
    lower.depth <- mean(x$cdepth[which(abs(x$cdepth-max(depth.interval)) == min(abs(x$cdepth-max(depth.interval))))])
    
    upper.light <- geometric.mean(x$light[which(abs(x$cdepth-min(depth.interval)) == min(abs(x$cdepth-min(depth.interval))))])
    lower.light <- geometric.mean(x$light[which(abs(x$cdepth-max(depth.interval)) == min(abs(x$cdepth-max(depth.interval))))])
    
    x$output <- log(upper.light/lower.light) / (lower.depth - upper.depth)
    
    if(return.col != F) {
      names(x)[which(names(x) == "output")] <- return.col
    }
    
    names(x)[which(names(x) == "light")] <- light.col
    names(x)[which(names(x) == "cdepth")] <- depth.col
  return(x)
  
}

#============================#
#             END            #
#============================#

theme_paper <- theme(panel.background = element_rect(fill = NA, color = "black"),
        panel.border = element_rect(fill = NA, color = "black"),
        panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text = element_text(size = 12, family = "serif", face = "bold"),
        axis.title = element_text(size = 14, family = "serif", face = "bold"))
