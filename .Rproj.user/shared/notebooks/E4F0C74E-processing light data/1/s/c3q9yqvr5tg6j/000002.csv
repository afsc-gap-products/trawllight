"0","```r
filter_stepwise <- function(x, binsize = 2, bin.gap = 6, agg.fun, ...) {
  profile_data <- x
  if(binsize != F) {
    print(\"Binned processing\")
    max.depth <- max(ceiling(profile_data$cdepth), na.rm = T)
    
     # Bin by depth with bins centered
    profile_data$cdepth <- findInterval(profile_data$cdepth, seq(0, max.depth, binsize), rightmost.closed = T, left.open = F) * binsize - binsize/2 
  }
  hauls <- unique(profile_data$haul)
  output <- data.frame(haul = numeric(), 
                       cdepth = numeric(), 
                       updown = character(),
                       llight = numeric(),
                       trans_llight = numeric(),
                       quality = numeric())
  
    # Calculate binned light level using user-specified function
      haul_profile <- aggregate(trans_llight ~ haul + updown + cdepth, data = profile_data, FUN = eval(parse(text = paste(agg.fun))))

  # Stepwise measurement removal loop  
  for(j in 1:length(hauls)) {  
    light_at_depth <- subset(haul_profile, haul == hauls[j]) 
      p2 <- 1
      while(p2 < nrow(light_at_depth) ) {
        if(p2 == 0) {
          p2 <- 1
        } 
        if(nrow(light_at_depth) >= (p2 + 1)) {
          if((light_at_depth$trans_llight[p2 + 1] > light_at_depth$trans_llight[p2])) {
            light_at_depth <- light_at_depth[-(p2),]
            p2 <- p2 - 2 # Jumps back two spaces
          }
        }
        p2 <- p2 + 1
      }
      # Assign data quality codes. -999 indicates gap of >=6 m and/or no measurements in upper 7m (0-1,1-3,3-5,5-7)
      if(max(diff(light_at_depth$cdepth)) <= quality.gap & min(light_at_depth$cdepth + 1) <= quality.gap) {
        light_at_depth$quality <- rep(1, nrow(light_at_depth))
      } else {
        light_at_depth$quality <- rep(-999, nrow(light_at_depth))
      }
      output <- rbind(output, light_at_depth)
  }
  return(output)
}
```"
